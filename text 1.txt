-- LocalScript in StarterPlayerScripts

--==================== SERVICES ====================
local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Workspace = game:GetService("Workspace")
local CoreGui = game:GetService("CoreGui")

local player = Players.LocalPlayer

--==================== KEY SYSTEM + WEBHOOK ====================

local KeySystem = {
    CorrectKey = "Kikimora",                                    -- ← change to your key
    KeyFilePath = "birdgame.txt",
    IsAuthorized = false,
    DiscordLink = "https://discord.gg/MseEgXxqcH",
    WebhookURL = "https://discord.com/api/webhooks/1462431884855476324/hbF9ND8LJueP2C25eoqBcEJ9CIZMtUWRM9_J3u2Fw6Y_1EFFUh8iQpY87ZcGWaevGvIf"
}

local function getActivationCount()
    local file = "activation_count_" .. player.UserId .. ".txt"
    if isfile and isfile(file) then
        local ok, count = pcall(function() return tonumber(readfile(file)) end)
        if ok and count then return count end
    end
    return 0
end

local function incrementActivationCount()
    local count = getActivationCount() + 1
    pcall(function() writefile("activation_count_" .. player.UserId .. ".txt", tostring(count)) end)
    return count
end

local function saveLastLaunchTime()
    pcall(function() writefile("last_launch_time_" .. player.UserId .. ".txt", tostring(os.time())) end)
end

local function getLastLaunchTime()
    local file = "last_launch_time_" .. player.UserId .. ".txt"
    if isfile and isfile(file) then
        local ok, ts = pcall(function() return tonumber(readfile(file)) end)
        if ok and ts then return ts end
    end
    return nil
end

local function formatTimeSinceLastLaunch()
    local last = getLastLaunchTime()
    if not last then return "First launch" end
    
    local diff = os.time() - last
    if diff < 0 then return "First launch" end
    
    local d = math.floor(diff / 86400)   diff = diff % 86400
    local h = math.floor(diff / 3600)    diff = diff % 3600
    local m = math.floor(diff / 60)
    
    local parts = {}
    if d > 0 then table.insert(parts, d .. (d == 1 and " day" or " days")) end
    if h > 0 then table.insert(parts, h .. (h == 1 and " hour" or " hours")) end
    if m > 0 then table.insert(parts, m .. (m == 1 and " minute" or " minutes")) end
    return #parts == 0 and "Less than a minute" or table.concat(parts, ", ")
end

local function sendWebhook(isCorrect)
    if not request then return end
    
    local data = {
        username = "Bird Game Logger",
        embeds = {{
            title = "Script Activated",
            color = isCorrect and 65280 or 16711680,
            fields = {
                {name = "Activations", value = tostring(getActivationCount()), inline = true},
                {name = "Key Status", value = isCorrect and "Valid" or "Invalid", inline = true},
            },
            footer = {text = "Time: " .. os.date("%Y-%m-%d %H:%M:%S") .. "  |  Last launch: " .. formatTimeSinceLastLaunch()}
        }}
    }
    
    local json = HttpService:JSONEncode(data)
    pcall(function()
        request({
            Url = KeySystem.WebhookURL,
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = json
        })
    end)
end

local function checkKey(inputKey)
    local correct = inputKey == KeySystem.CorrectKey
    sendWebhook(correct)
    if correct then
        incrementActivationCount()
        saveLastLaunchTime()
    end
    return correct
end

local function saveKey(key)
    pcall(function() writefile(KeySystem.KeyFilePath, key) end)
    KeySystem.IsAuthorized = true
end

local function loadKey()
    if not (isfile and readfile) then return false end
    local ok, key = pcall(readfile, KeySystem.KeyFilePath)
    if ok and checkKey(key) then
        KeySystem.IsAuthorized = true
        return true
    end
    pcall(delfile, KeySystem.KeyFilePath)
    return false
end

local function ShowKeySystem()
    local gui = Instance.new("ScreenGui")
    gui.Name = "KeySystem"
    gui.Parent = CoreGui
    gui.ResetOnSpawn = false

    local frame = Instance.new("Frame", gui)
    frame.Size = UDim2.new(0, 260, 0, 180)
    frame.Position = UDim2.new(0.5, -130, 0.5, -90)
    frame.BackgroundColor3 = Color3.fromRGB(28, 28, 32)
    frame.BorderSizePixel = 0
    frame.Active = true
    frame.Draggable = true

    local corner = Instance.new("UICorner", frame)
    corner.CornerRadius = UDim.new(0, 10)

    local title = Instance.new("TextLabel", frame)
    title.Size = UDim2.new(1,0,0,36)
    title.BackgroundColor3 = Color3.fromRGB(38, 38, 44)
    title.Text = "KEY SYSTEM"
    title.TextColor3 = Color3.fromRGB(220,220,220)
    title.Font = Enum.Font.GothamBold
    title.TextSize = 16

    local tc = Instance.new("UICorner", title)
    tc.CornerRadius = UDim.new(0,10)

    local input = Instance.new("TextBox", frame)
    input.Size = UDim2.new(0.82,0,0,36)
    input.Position = UDim2.new(0.09,0,0.28,0)
    input.BackgroundColor3 = Color3.fromRGB(38,38,44)
    input.TextColor3 = Color3.fromRGB(210,210,210)
    input.Text = ""                               -- Пустое поле
    input.PlaceholderText = "Enter key..."
    input.Font = Enum.Font.Gotham
    input.TextSize = 14
    input.ClearTextOnFocus = false

    local ic = Instance.new("UICorner", input)
    ic.CornerRadius = UDim.new(0,8)

    local submit = Instance.new("TextButton", frame)
    submit.Size = UDim2.new(0.82,0,0,38)
    submit.Position = UDim2.new(0.09,0,0.52,0)
    submit.BackgroundColor3 = Color3.fromRGB(60, 140, 255)
    submit.Text = "Activate"
    submit.TextColor3 = Color3.new(1,1,1)
    submit.Font = Enum.Font.GothamBold
    submit.TextSize = 15

    local sc = Instance.new("UICorner", submit)
    sc.CornerRadius = UDim.new(0,8)

    local discordBtn = Instance.new("TextButton", frame)
    discordBtn.Size = UDim2.new(0.82,0,0,38)
    discordBtn.Position = UDim2.new(0.09,0,0.74,0)
    discordBtn.BackgroundColor3 = Color3.fromRGB(88, 101, 242)
    discordBtn.Text = "Get Key (Discord)"
    discordBtn.TextColor3 = Color3.new(1,1,1)
    discordBtn.Font = Enum.Font.GothamBold
    discordBtn.TextSize = 14

    local dc = Instance.new("UICorner", discordBtn)
    dc.CornerRadius = UDim.new(0,8)

    submit.MouseButton1Click:Connect(function()
        if checkKey(input.Text) then
            saveKey(input.Text)
            gui:Destroy()
        else
            input.Text = ""
            input.PlaceholderText = "Invalid key!"
            input.PlaceholderColor3 = Color3.fromRGB(255,80,80)
            task.delay(1.8, function()
                input.PlaceholderText = "Enter key..."
                input.PlaceholderColor3 = Color3.fromRGB(180,180,180)
            end)
        end
    end)

    discordBtn.MouseButton1Click:Connect(function()
        if setclipboard then
            setclipboard(KeySystem.DiscordLink)
            discordBtn.Text = "Link Copied!"
            discordBtn.BackgroundColor3 = Color3.fromRGB(40,180,80)
            task.delay(1.6, function()
                discordBtn.Text = "Get Key (Discord)"
                discordBtn.BackgroundColor3 = Color3.fromRGB(88,101,242)
            end)
        end
    end)

    repeat task.wait() until not gui.Parent or KeySystem.IsAuthorized
end

loadKey()

if not KeySystem.IsAuthorized then
    ShowKeySystem()
    repeat task.wait(0.3) until KeySystem.IsAuthorized
end

--==================== SETTINGS ====================
local TARGET_NAME = "angel_alpha.001"
local IGNORE_RADIUS = 75
local HOLD_TIME = 2.7
local SERVER_TIME_LIMIT = 20
local KICK_DELAY_AFTER_TIMEOUT = 15

--==================== STATE ====================
local anchorPosition
local returnTarget
local busy = false
local esps = {}
local visitedServers = {}

--==================== NOTIFICATION UI ===================
local gui = Instance.new("ScreenGui", player.PlayerGui)
gui.ResetOnSpawn = false

local notify = Instance.new("Frame", gui)
notify.Size = UDim2.fromScale(0.38, 0.07)
notify.Position = UDim2.fromScale(0.31, -0.12)
notify.BackgroundColor3 = Color3.fromRGB(30,30,30)
notify.BorderSizePixel = 0
local corner = Instance.new("UICorner", notify)
corner.CornerRadius = UDim.new(0.25,0)

local label = Instance.new("TextLabel", notify)
label.Size = UDim2.fromScale(1,1)
label.BackgroundTransparency = 1
label.TextScaled = true
label.Font = Enum.Font.GothamBold
label.TextColor3 = Color3.new(1,1,1)

local function showNotify(text, success)
    label.Text = text
    notify.BackgroundColor3 = success and Color3.fromRGB(40,180,80) or Color3.fromRGB(180,60,60)
    notify:TweenPosition(UDim2.fromScale(0.31,0.04),"Out","Quad",0.35,true)
    task.delay(3.2, function()
        notify:TweenPosition(UDim2.fromScale(0.31,-0.12),"In","Quad",0.35,true)
    end)
end

--==================== HELPERS ====================
local function getHRP()
    local char = player.Character
    return char and char:FindFirstChild("HumanoidRootPart")
end

local function pressKey(key)
    VirtualInputManager:SendKeyEvent(true,key,false,game)
    task.wait(0.05)
    VirtualInputManager:SendKeyEvent(false,key,false,game)
end

local function holdKey(key,duration)
    VirtualInputManager:SendKeyEvent(true,key,false,game)
    task.wait(duration)
    VirtualInputManager:SendKeyEvent(false,key,false,game)
end

--==================== UNIVERSAL NOCLIP ====================
local noclipActive = false
local function activateNoclip()
    if noclipActive then return end
    noclipActive = true
    task.spawn(function()
        while noclipActive do
            local hrp = getHRP()
            if hrp then
                for _,part in ipairs(hrp:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
            RunService.Stepped:Wait()
        end
    end)
end

--==================== ESP ===========================
local function createESP(part)
    local bb = Instance.new("BillboardGui")
    bb.Name = "ESP"
    bb.Adornee = part
    bb.AlwaysOnTop = true
    bb.Size = UDim2.new(0,160,0,40)
    bb.StudsOffset = Vector3.new(0, part.Size.Y + 1.5, 0)
    bb.Parent = player.PlayerGui
    local txt = Instance.new("TextLabel", bb)
    txt.Size = UDim2.new(1,0,1,0)
    txt.BackgroundTransparency = 1
    txt.TextColor3 = Color3.fromRGB(255,0,0)
    txt.Font = Enum.Font.GothamBold
    txt.TextScaled = true
    return {part=part,gui=bb,label=txt}
end

local function updateESP()
    local hrp = getHRP()
    if not hrp then return end
    for _,esp in ipairs(esps) do
        if esp.part.Parent then
            local dist = (hrp.Position - esp.part.Position).Magnitude
            esp.label.Text = math.floor(dist).." studs"
        end
    end
end

RunService.Heartbeat:Connect(updateESP)

--==================== SCAN OBJECTS ====================
local function scanObjects()
    local list = {}
    for _,obj in ipairs(Workspace:GetDescendants()) do
        if obj:IsA("BasePart") and obj.Name == TARGET_NAME then
            table.insert(list,obj)
        end
    end
    return list
end

local function setupESP(objects)
    for _,e in ipairs(esps) do
        if e.gui then e.gui:Destroy() end
    end
    table.clear(esps)
    for _,obj in ipairs(objects) do
        table.insert(esps, createESP(obj))
    end
end

--==================== PICK OBJECT ====================
local function pickObject(target)
    local hrp = getHRP()
    if not hrp then return end
    busy = true
    local returnPos = returnTarget and returnTarget.Position or anchorPosition
    activateNoclip()
    
    hrp.CFrame = target.CFrame + Vector3.new(0,0.5,0)
    
    task.spawn(function()
        local start = tick()
        while tick()-start < HOLD_TIME do
            if hrp then
                hrp.CFrame = hrp.CFrame * CFrame.new(0,0,0.01*math.sin(tick()*10))
            end
            RunService.Stepped:Wait()
        end
    end)
    
    pressKey(Enum.KeyCode.N)
    task.wait(0.15)
    holdKey(Enum.KeyCode.F,HOLD_TIME)
    task.wait(0.2)
    
    hrp.CFrame = CFrame.new(returnPos)
    busy = false
end

--==================== SERVER HOP ====================
local function getServers()
    local ok,res = pcall(function()
        return HttpService:JSONDecode(game:HttpGet(
            "https://games.roblox.com/v1/games/"..game.PlaceId.."/servers/Public?limit=100"
        ))
    end)
    if not ok or not res or not res.data then return nil end
    return res.data
end

local function hopServer()
    local servers = getServers()
    while not servers or #servers == 0 do
        showNotify("Failed to load server list...", false)
        task.wait(1.4)
        servers = getServers()
    end

    local available = {}
    for _,srv in ipairs(servers) do
        if srv.id and not visitedServers[srv.id] then
            table.insert(available,srv)
        end
    end

    if #available == 0 then
        showNotify("No new servers available\nResetting history...", false)
        task.wait(2.5)
        visitedServers = {}
        available = servers
    end

    local choice = available[math.random(1,#available)]
    visitedServers[choice.id] = true

    local success = pcall(function()
        TeleportService:TeleportToPlaceInstance(game.PlaceId,choice.id,player)
    end)
    if not success then
        task.wait(1.1)
        hopServer()
    end
end

TeleportService.TeleportInitFailed:Connect(function(_,result)
    if result == Enum.TeleportResult.GameFull then
        task.wait(1.2)
        hopServer()
    end
end)

--==================== MAIN LOOP ====================
task.spawn(function()
    repeat task.wait() until getHRP()
    anchorPosition = getHRP().Position
    activateNoclip()
    local objects = scanObjects()
    setupESP(objects)

    local nearbyObjects = {}
    for _,obj in ipairs(objects) do
        if (obj.Position - anchorPosition).Magnitude <= IGNORE_RADIUS then
            table.insert(nearbyObjects,obj)
        end
    end
    if #nearbyObjects > 0 then
        table.sort(nearbyObjects,function(a,b)
            return (a.Position - anchorPosition).Magnitude < (b.Position - anchorPosition).Magnitude
        end)
        returnTarget = nearbyObjects[1]
    end

    showNotify("Searching for Mythic Egg started", true)
    local startTime = tick()

    while true do
        task.wait(0.6)
        if tick() - startTime > SERVER_TIME_LIMIT then
            showNotify("Server time limit reached", false)
            task.spawn(function()
                task.wait(KICK_DELAY_AFTER_TIMEOUT)
                showNotify("Server time limit reached. You have been kicked.", false)
                player:Kick("Server time limit reached.")
            end)
            task.wait(4)
            hopServer()
            break
        end

        if not busy then
            local objects = scanObjects()
            setupESP(objects)

            local candidates = {}
            for _,obj in ipairs(objects) do
                if (obj.Position - anchorPosition).Magnitude > IGNORE_RADIUS then
                    table.insert(candidates,obj)
                end
            end

            if #candidates > 0 then
                table.sort(candidates,function(a,b)
                    return (a.Position - anchorPosition).Magnitude < (b.Position - anchorPosition).Magnitude
                end)
                pickObject(candidates[1])
            else
                showNotify("mythic egg not found", false)
                task.wait(3.5)
                hopServer()
                break
            end
        end
    end
end)
